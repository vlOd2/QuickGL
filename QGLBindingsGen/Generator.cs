using System.Text;
using System.Xml.Linq;
using QGLBindingsGen.CParsing;
using QGLBindingsGen.GLRegistry;

namespace QGLBindingsGen;

internal static class Generator
{
    #region Components
    private static void AppendStruct(CStruct s, StringBuilder builder)
    {
        builder.AppendLine("[StructLayout(LayoutKind.Sequential)]");
        builder.AppendLine($"public unsafe struct {s.Name}");
        builder.AppendLine("{");
        foreach (KeyValuePair<string, CType> field in s.Fields)
        {
            if (field.Value.NativeConvertedName != null)
                builder.AppendLine($"    /// pointer to {field.Value.NativeConvertedName}");
            builder.AppendLine($"    public {field.Value} {field.Key};");
        }
        builder.AppendLine("}");
    }

    private static void AppendEnum(CEnum e, StringBuilder builder)
    {
        builder.AppendLine($"public enum {e.Name}");
        builder.AppendLine("{");
        foreach (KeyValuePair<string, string> value in e.Values)
        {
            if (value.Value != "")
            {
                if (value.Value.StartsWith('-'))
                    builder.AppendLine($"    {value.Key} = unchecked((int){value.Value}),");
                else
                    builder.AppendLine($"    {value.Key} = {value.Value},");
            }
            else
                builder.AppendLine($"    {value.Key},");
        }
        builder.AppendLine("}");
    }

    private static void AppendDef(CDefinition def, StringBuilder builder)
    {
        if (def.Callback == null)
        {
            builder.AppendLine($"public struct {def.Name} {{ }}");
            return;
        }
        builder.AppendLine("[UnmanagedFunctionPointer(CallingConvention.Winapi)]");
        builder.AppendLine($"public unsafe delegate {def.Callback.ReturnType} {def.Name}(" +
            $"{string.Join(", ", def.Callback.Args.Select(p => $"{p.Value} {p.Key}"))});");
    }

    private static void AppendFuncWrapper(CFunction func, StringBuilder builder)
    {
        builder.Append($"    public static {func.ReturnType} {func.Name}(");
        builder.Append(string.Join(", ", func.Args.Select(p => $"{p.Value} {p.Key}")));
        builder.Append(") { ");

        builder.Append($"QGLFeature.VerifyFunc((nint)_{func.Name}); ");
        if (func.ReturnType.Name != "void" || func.ReturnType.PointerCount != 0)
            builder.Append("return ");
        builder.Append($"_{func.Name}({string.Join(", ", func.Args.Keys)});");

        builder.AppendLine(" }");
    }
    #endregion

    #region Generators
    private static void GenerateFileHeader(StringBuilder builder, string @namespace, List<string> extraImports = null)
    {
        builder.AppendLine($"// This file has been automatically generated");
        builder.AppendLine($"// Generated by: QGLBindingsGen (https://github.com/vlOd2/QGLBindingsGen)");

        builder.AppendLine("using System.Runtime.InteropServices;");
        builder.AppendLine("using QuickGL.Internal;");
        if (extraImports != null && extraImports.Count > 0) 
        {
            foreach (string import in extraImports)
                builder.AppendLine($"using {import};");
        }
        builder.AppendLine();
        builder.AppendLine($"namespace {@namespace};");
    }

    private static void GenerateOtherTypes(CParserContext ctx, StringBuilder builder)
    {
        builder.AppendLine("#region Other types");

        foreach (CDefinition def in ctx.Definitions)
        {
            AppendDef(def, builder);
            builder.AppendLine();
        }

        foreach (CStruct s in ctx.Structs)
        {
            AppendStruct(s, builder);
            builder.AppendLine();
        }

        foreach (CEnum e in ctx.Enums)
        {
            AppendEnum(e, builder);
            builder.AppendLine();
        }

        builder.AppendLine("#endregion");
    }

    private static void GenerateConstants(CParserContext ctx, StringBuilder builder)
    {
        builder.AppendLine("    #region Constants");
        foreach (CConstant cconst in ctx.Constants)
        {
            string val = cconst.Value;
            bool isNumerical = char.IsAsciiDigit(val[0]) || (val[0] == '-' && val.Length > 1 && char.IsAsciiDigit(val[1]));
            if (cconst.CType.PointerCount == 0 && isNumerical)
            {
                if (cconst.CType.Name == "float" && !val.ToLower().EndsWith('f') && val.Contains('.'))
                {
                    val += "F";
                    Logger.Info($"Appended suffix to float constant {cconst.Name}: {val}");
                }
                else if (cconst.CType.Name == "double" && !val.ToLower().EndsWith('d') && val.Contains('.'))
                {
                    val += "D";
                    Logger.Info($"Appended suffix to double constant {cconst.Name}: {val}");
                }
                else if (cconst.CType.Name == "uint" && !val.ToLower().EndsWith('u'))
                {
                    val += "U";
                    Logger.Info($"Appended suffix to uint constant {cconst.Name}: {val}");
                }
                else if (cconst.CType.Name == "long" && !val.ToLower().EndsWith('l'))
                {
                    val += "L";
                    Logger.Info($"Appended suffix to long constant {cconst.Name}: {val}");
                }
                else if (cconst.CType.Name == "ulong" && !val.ToLower().EndsWith("ul"))
                {
                    val += "UL";
                    Logger.Info($"Appended suffix to ulong constant {cconst.Name}: {val}");
                }
            }
            builder.AppendLine($"    public const {cconst.CType} {cconst.Name} = {val};");
        }
        builder.AppendLine("    #endregion");
    }

    private static void GenerateFunctionPtrs(CParserContext ctx, StringBuilder builder, string procAddrFunc)
    {
        builder.AppendLine("    #region Function pointers");

        foreach (CFunction func in ctx.Functions)
            builder.AppendLine($"    internal static {GetFuncDelegatePtrType(func)} _{func.Name} = null;");
        builder.AppendLine();

        builder.AppendLine("    internal static void Load()");
        builder.AppendLine("    {");
        foreach (CFunction func in ctx.Functions)
            builder.AppendLine($"        _{func.Name} = ({GetFuncDelegatePtrType(func)}){procAddrFunc}(\"{func.Name}\");");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    internal static void Unload()");
        builder.AppendLine("    {");
        foreach (CFunction func in ctx.Functions)
            builder.AppendLine($"        _{func.Name} = null;");
        builder.AppendLine("    }");

        builder.AppendLine("    #endregion");
    }

    private static void GenerateFunctionWrappers(CParserContext ctx, StringBuilder builder)
    {
        builder.AppendLine("    #region Function wrappers");
        foreach (CFunction func in ctx.Functions)
            AppendFuncWrapper(func, builder);
        builder.AppendLine("    #endregion");
    }
    #endregion

    private static string GetFuncDelegatePtrType(CFunction func)
    {
        StringBuilder builder = new();
        builder.Append($"delegate* unmanaged<");
        if (func.Args.Count > 0)
            builder.Append(string.Join(", ", func.Args.Values) + ", ");
        builder.Append($"{func.ReturnType}>");
        return builder.ToString();
    }

    public static string GetGLFeatureClassName(GLFeature feature)
        => feature.Name.Replace("GL_", "GL").Replace("VERSION_", "").Replace("_", "").Trim();

    public static string Generate(CParserContext ctx, string name, string @namespace, string procAddrFunc)
    {
        StringBuilder builder = new();

        GenerateFileHeader(builder, @namespace);
        builder.AppendLine();
        if (ctx.Definitions.Count > 0 || ctx.Structs.Count > 0 || ctx.Enums.Count > 0)
        {
            GenerateOtherTypes(ctx, builder);
            builder.AppendLine();
        }

        builder.AppendLine($"public static unsafe class {name}");
        builder.AppendLine("{");
        GenerateConstants(ctx, builder);
        builder.AppendLine();
        GenerateFunctionPtrs(ctx, builder, procAddrFunc);
        builder.AppendLine();
        GenerateFunctionWrappers(ctx, builder);
        builder.AppendLine("}");

        return builder.ToString();
    }

    public static string GenerateGLFeature(GLFeature feature, string @namespace)
    {
        StringBuilder builder = new();

        GenerateFileHeader(builder, @namespace);
        builder.AppendLine();
        if (feature.ParserContext.Structs.Count > 0 || feature.ParserContext.Definitions.Count > 0)
        {
            GenerateOtherTypes(feature.ParserContext, builder);
            builder.AppendLine();
        }

        builder.AppendLine($"public static unsafe class {GetGLFeatureClassName(feature)}");
        builder.AppendLine("{");
        GenerateConstants(feature.ParserContext, builder);
        builder.AppendLine();
        GenerateFunctionPtrs(feature.ParserContext, builder, "QGL.GetGLProcAddress");
        builder.AppendLine();
        GenerateFunctionWrappers(feature.ParserContext, builder);
        builder.AppendLine();
        builder.Append($"    internal static QGLFeature FeatureInfo => ");
        builder.AppendLine($"new(\"{feature.Name}\", {(feature.IsExtension ? "true" : "false")}, {(feature.IsES ? "true" : "false")});");
        builder.AppendLine("}");

        return builder.ToString();
    }

    public static string GenerateGLBindingsMgr(List<GLFeature> features, string @namespace)
    {
        StringBuilder builder = new();

        GenerateFileHeader(builder, @namespace, features.Any(feature => feature.IsExtension) ? [$"{@namespace}.Extensions"] : null);
        builder.AppendLine();

        builder.AppendLine($"internal static unsafe class GLBindingsManager");
        builder.AppendLine("{");
        builder.AppendLine("    internal static void Load()");
        builder.AppendLine("    {");
        foreach (GLFeature feature in features)
        {
            string className = GetGLFeatureClassName(feature);
            builder.AppendLine($"        if (QGL.IsFeatureSupported({className}.FeatureInfo)) {className}.Load();");
        }
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    internal static void Unload()");
        builder.AppendLine("    {");
        foreach (GLFeature feature in features)
            builder.AppendLine($"        {GetGLFeatureClassName(feature)}.Unload();");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return builder.ToString();
    }
}
